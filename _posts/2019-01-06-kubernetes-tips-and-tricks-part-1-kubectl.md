---
layout: page
title: "Kubernetes tips and tricks, part&nbsp;1: kubectl&nbsp;&&nbsp;friends"
snippet: |
  In this quick post, Iâ€™ll try to highlight some of useful kubectl features
  as well as few little things that you may have missed in the docs.
tags: [kubernetes]
comments-issue-id: 1
---

While many Kubernetes newcomers routinely use the [dashboard](https://github.com/kubernetes/dashboard)
or similar user interface, `kubectl` - the official CLI - often goes unappreciated. I believe
`kubectl` is _the_ tool to learn well, as it is very powerful and can do just about everything. In
this quick post, I'll try to highlight some of its notably useful features as well as few little
things that you may have missed in the docs.

## 1. Shell completion
Make sure you install `kubectl`'s [shell completion](https://kubernetes.io/docs/tasks/tools/install-kubectl/#enabling-shell-autocompletion).
Among other things, it will autocomplete resource kinds and resource names for you, which
can be especially useful for resources with autogenerated names, such as `Pod`s.

### Z shell
If you're a [zsh](http://zsh.sourceforge.net/) user (as I am), I highly suggest that you get
its [kubectl plugin](https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/kubectl/kubectl.plugin.zsh).
With [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh), which you're probably already using, it's super easy to turn on. Besides
integrated help for most `kubectl` flags, it will also give you a handful of useful aliases out of the box. Some of my favourites include:

* `k` = `kubectl`
* `kgd` = `kubectl get deployment`
* `kdd` = `kubectl describe deployment`
* `kgp` = `kubectl get pods`

See the [plugin](https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/kubectl/kubectl.plugin.zsh) for the
full list.

## 2. Save precious keystrokes
Even without shell completion (though it's highly recommended), you can save a few keystrokes
here and there. For example, all of these are equivalent:

```shell
kubectl get pods
kubectl get pod
kubectl get po
```

## 3. Switching between namespaces
If you find yourself working with multiple namespaces at once, there are few traditional ways
to "move" between them:

1. keep separate `kubectl` _context_ for each namespace, perhaps switching between
them using `kubectl config use-context`
2. override the namespace when invoking `kubectl`, via `-n` flag (e.g. `kubectl get po -n my_namespace`)

First option becomes unwieldy very quickly for more than a few namespaces. Second option
is a nuisance to write every time, also being very easy to forget and perform an action
in a different namespace than you wanted.

Admittedly, this is where `kubectl` could do a lot better. There are various 3rd party tools
to overcome this, but I've personally settled with [kubectx & kubens](https://github.com/ahmetb/kubectx).

### kubectx/kubens
[kubectx & kubens](https://github.com/ahmetb/kubectx) is a pair of tools to aid with context
and namespace switching.

While `kubectx` is useful and can manage contexts easily, I use `kubens` way more often,
in tandem with aliases and bash completion:

* List namespaces:
```shell
kns
```

* Switch the current context to a namespace:
```shell
kns my_namespace
```

* Switch the current context to the previous namespace (very useful when switching back
and forth between two namespaces):
```
kns -
```

## 4. Labels everywhere
You probably know that just about any Kubernetes object can have [labels](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/) attached to it.
In addition to labels, there are also [annotations](https://kubernetes.io/docs/concepts/overview/working-with-objects/annotations/).

[Labels and Annotations in Kubernetes](https://vsupalov.com/kubernetes-labels-annotations-difference/) is a good article explaining the differences between the two, but four our purposes, these are 
the most important:
* Labels are *indexed* and thus optimized for quick access.
* Annotations are intended for non-identifying pieces of metadata.

That said, it comes as no surprise that `kubectl` supports **querying by labels** at
almost every corner. For example, consider the following deployment:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
```

* You can now query `Pod`s spawned by that deployment:
```shell
kubectl get po -l app=nginx
```
* Label queries are supported by many `kubectl` subcommands. For instance, to retrieve logs
from the last 5 minutes, across all relevant `Pod`s:
```shell
kubectl logs --since 5m -l app=nginx
```

If you're consistent with your labeling convention, e.g. giving all your app-related
Kubernetes objects (such as `Service`, `Ingress`) the same label (say `app`), searching
for those then becomes easier. This might not be all that useful for most objects,
but comes very handy for `Pod`s, because their names are autogenerated identifiers.

## 5. Output formats
It's also worth keeping in mind that many `kubectl` subcommands support multiple
output formats. You'll find a comprehensive overview in the [docs](https://kubernetes.io/docs/reference/kubectl/overview/#output-options), but here's
a quick intro.

### 5.1. wide
While the standard `kubectl get po -l app=nginx` will spit out something along these lines:

```shell
NAME                                READY   STATUS    RESTARTS   AGE
nginx-deployment-766d958db5-2f8t9   1/1     Running   0          4m37s
nginx-deployment-766d958db5-7868d   1/1     Running   0          4m37s
```

adding `-o wide` will extend the columns to:
```shell
NAME                                READY   STATUS    RESTARTS   AGE     IP               NODE        NOMINATED NODE   READINESS GATES
nginx-deployment-766d958db5-2f8t9   1/1     Running   0          4m45s   172.21.33.162    luft-c-w1   <none>           <none>
nginx-deployment-766d958db5-7868d   1/1     Running   0          4m45s   172.21.208.136   luft-c-w3   <none>           <none>
```

Every resource has a different set of _default_ and _"wide"_ printed columns.

### 5.2. json/yaml
Those two do just what you'd expect. They print the most complete representations
of an object (or multiple objects), and they are especially powerful when
piped into [jq](https://stedolan.github.io/jq/) or [yq](https://github.com/mikefarah/yq).

### name
Will print out just the object name. Might not seem that useful on first glance,
but it's often used in scripts, e.g. when iterating over deployment's `Pod`s.

E.g. `kubectl get po -l app=nginx -o name` will print:

```shell
pod/nginx-deployment-766d958db5-2f8t9
pod/nginx-deployment-766d958db5-7868d
```

Notice the `pod/` prefix in this case - that's because `-o name` output will
include the resource _kind_.

### 5.3. jsonpath
While you can combine `-o json` with piping the command output
to [jq](https://stedolan.github.io/jq/), sometimes you can do just with the
built-in [JSONPath support](https://kubernetes.io/docs/reference/kubectl/jsonpath/).

`kubectl get po nginx-deployment-766d958db5-2f8t9 -o jsonpath={.metadata.name}` will print:
```shell
nginx-deployment-766d958db5-2f8t9
```

#### Finding your (json)path
To navigate the object structure, you can either try inspecting the output
of `-o json` and starting from there, or just refer to the API docs - for instance,
here's [documentation for the `Pod` resource](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.13/#pod-v1-core).

#### jsonpath with Lists
The above example works okay when the `kubectl get` subcommand yields just a single
object. When you're dealing with multiple objects, though, you will get a `List`,
which needs to be iterated through using `range-end`:

```shell
kubectl get po -l app=nginx -o 'jsonpath={range .items[*]}{.metadata.name}:{end}' | tr ":" "\n"
```

will give you
```
nginx-766d958db5-2f8t9
nginx-766d958db5-7868d
```

Notice how _":"_ is inserted in the JSONPath expression and then replaced with a 
newline using `tr` - this is a common pattern to get newlines into the output,
which enables feeding resulting values into other tools.

### 5.3. custom-columns
`-o custom-columns` nicely combines tabular output with JSONPath support.

For instance, to list `Pods` along with image names:
```shell
kubectl get po -o 'custom-columns=name:metadata.name,images:spec.containers[*].image'
```

will give you
```
name                                       images
nginx-766d958db5-2f8t9                     nginx:1.7.9
nginx-766d958db5-7868d                     nginx:1.7.9
tiller-deploy-6995d897d4-6b4xj             gcr.io/kubernetes-helm/tiller:v2.9.1
```

Notice that you do not need concern yourself with iterating over `List`s, since the
JSONPath used with `custom-columns` format already operates on individual items.

## Conclusion
While this installment of Kubernetes tips and tricks does not introduce anything
particularly mind-blowing or new, hopefully I've managed to convince you
that `kubectl` is a very capable tool.

In next posts, we'll look more into the runtime side of `Pods`: running one-off pods,
working with logs, exec'ing into pods and copying files, or inspecting a pod's live
traffic with Wireshark.